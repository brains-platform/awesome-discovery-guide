# Redis游记

## 缓存有哪些类型

### 本地缓存

进程中的内存缓存（JVM中），可以用 LRUMap 来实现，常见开源实现：Guava、Ehcache[?]、caffeine[?]

优点：内存访问，没有远程交互开销，性能最好

缺点：受限于单机容量，一般缓存较小且无法扩展；分布式场景使用涉及缓存更新问题

### 分布式缓存

集中是缓存，常见开源实现：Memcache、Redis

优点：具有良好的水平扩展能力，对较大数据量的场景也能应付自如

缺点：需要进行远程请求，性能不如本地缓存

### 多级缓存

为了平衡以上两种缓存的优缺点，实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中，本地缓存的更新通过MQ/失效时间等方式更新

## 缓存淘汰策略

不管是本地缓存还是分布式缓存，为了保证较高性能，都是使用内存来保存数据，由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。

一般的剔除策略有 FIFO淘汰最早数据、LRU剔除最近最少使用、和 LFU剔除最近使用频率最低的数据几种策略。

* FIFO：First Input First Output，简单说就是指先进先出。
* LRU：Least Recently Used，最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。
* LFU：Least Frequently Used，最不经常使用策略,在一段时间内,数据被使用频次最少的,优先被淘汰。

大家熟悉的LinkedHashMap中也实现了Lru算法，实现如下：

```java
public class LRUCache<K,V> extends LinkedHashMap<K,V> {

  private int initialCapacity;

  public LRUCache(int initialCapacity) {
    super(initialCapacity,0.75f,true);
    this.initialCapacity = initialCapacity;
  }

  @Override
  protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
    return this.size() > initialCapacity;
  }
}
```

## Redis与Memcache对比

* 数据格式支持：相比 MC，Redis 有一个非常大的优势，就是除了 K-V 之外，还支持多种数据格式，例如 list、set、sorted set、hash 等
* 线程模型：Redis 采用单线程模式处理请求，这样做的原因有 2 个：一个是因为采用了非阻塞的异步事件处理机制；另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价；
* 持久化：Redis支持持久化 不仅仅可以用作缓存，也可以用作 NoSQL 数据库
* 分布式：MC分布式需要依赖客户端工具如xMemcached，Redis2.8引入哨兵提供主从同步机制，3.5后提供Cluster 集群部署能力，能够提供高可用服务
* 其他：MC key 不能超过 250 个字节；value 不能超过 1M 字节；key 的最大失效时间是 30 天；

## Redis基础功能

### String

String 类型是 Redis 中最常使用的类型，内部的实现是通过 SDS（Simple Dynamic String ）来存储的。SDS 类似于 Java 中的 ArrayList，可以通过预分配冗余空间的方式来减少内存的频繁分配。

String的实际应用场景比较广泛的有：

* 缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力；
* 计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存；
* 共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。

### Hash

hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。

string + json也是存储对象的一种方式，那么存储对象时，到底用string + json还是用hash呢？两种存储方式的对比如下表所示。

| 对比 | string + json | hash |
| ---- | ---- | ---- |
| 效率 | 很高 | 高 |
| 容量 | 低 | 低 |
| 灵活性 | **低** | 高 |
| 序列化 | 简单 | **复杂** |

当对象的某个属性需要频繁修改时，不适合用string+json，因为它不够灵活，每次修改都需要重新将整个对象序列化并赋值，如果使用hash类型，则可以针对某个属性单独修改，没有序列化，也不需要修改整个对象。当对象的某个属性不是基本类型或字符串时，使用hash类型就必须手动进行复杂序列化，比如，商品的标签是一个标签对象的列表，value想存储对象列表也还是要使用json来序列化，这样的话序列化工作就太繁琐了，不如直接用string + json的方式存储来的简单。

### List

有序列表，实际应用场景花样多：

* 列表型的数据结构：类似粉丝列表、文章的评论列表之类
* Lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定，可以基于 List 实现分页查询
* 简单的消息队列：生产者可以通过lpush命令从左边插入数据，多个数据消费者，可以使用brpop命令阻塞列表直到等待超时或发现可弹出元素为止

#### List相关命令

```shell
# 返回[start，end]区间上的所有元素。start、end是索引，比如0 -1就是返回所有元素
lrange  key start  end
# 在元素value1之前/之后插入元素value2,value2是要插入的元素
linsert  key  before/after  value1  value2
# 往列表的头部（左边）推入一个或多个元素
lpush key value1 value2 .....
# 同上，只是key不存在时，不执行操作（不会自动创建）
lpushx key value1 value2 ......
# 弹出列表的第一个元素，会从列表中移除并返回该元素
lpop key
# rpush,rpushx,rpop 反之从尾部（右边）操作

# 弹出一个或多个的列表的第一个元素，如果列表为空会阻塞列表直到等待超时或发现可弹出元素为止
blpop  key1  key2  ....   timeout
# 返回列表中的元素个数
llen  key
# 给指定索引处的元素设置值（即修改元素值）
lset  key  index  value
```

### Set

String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。使用场景不多，可以使用Set数据类型跟踪一些唯一性数据

* 某博客的访客IP记录
* 标签（tag）：兴趣爱好、博客关键词

### Sorted Set

有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。比较典型的使用场景就是多维度排行榜：时间、评分、数量等

```shell
# 查询score介于start、end之前的用户
zrangebyscore key start end
```

Redis实现延时队列：时间戳作为score，调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据

## Redis高级用法

### Bitmap(需要进一步理解整理)

操作String数据结构的key所存储的字符串指定偏移量上的位，返回原位置的值。

活跃用户场景解析

#### setbit命令

设置或修改`key`上的偏移量`（offset）`的位`（value）`的值。

语法：`setbit key offset value`
返回值：指定偏移量`（offset）`原来存储的值

### HyperLogLog(需要进一步理解整理)

供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；

### Geospatial(需要进一步理解整理)

可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？

### pub/sub

订阅发布功能，可以用作简单的消息队列。不想引入消息队列的情况下，可以用来做本地缓存的更新

缺点：在消费者下线的情况下，生产的消息会丢失，需要使用专业的消息队列RabbitMQ等

### Pipeline

可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。而且Pipeline 实现的原理是队列，而队列的原理是时先进先出，这样就保证数据的顺序性。Pipeline 的默认的同步的个数为53个，也就是说arges中累加到53条数据时会把数据提交，类似于InfluxDB的BathPoints。pipeline中发送的每个command都会被server立即执行，一个command执行失败并不影响其他的。

### 其他高级用法

#### RedisSearch [?]

#### Redis Module [?]

#### Redis-ML [?]

#### 适用场景

不适合：有些系统可能对可靠性要求很高，每次操作都需要立马知道这次操作是否成功，是否数据已经写进redis了，那这种场景就不适合。

适  用：批量的将数据写入redis，非主干业务可以后台执行的，允许一定比例的写入失败，后期有补偿机制就行了，比如短信群发这种场景，如果一下群发10000条，按照第一种模式去实现，那这个请求过来，要很久才能给客户端响应，这个延迟就太长了，如果客户端请求设置了超时时间5秒，那肯定就抛出异常了，而且本身群发短信要求实时性也没那么高，这时候用pipeline最好了。

#### 集群下优化RedisPipeline操作（需要进一步理解整理）

### Lua

Redis 支持提交 Lua 脚本来执行一系列的功能。

#### Redis中使用Lua的好处

* 减少网络开销：可以将多个请求通过脚本的形式一次发送，减少网络时延，这一点与Pipeline部分特性重合
* 原子操作：redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务。
* 复用：客户端发送的脚步会永久存在redis中，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑。

#### lua常用命令

在redis里面使用lua脚本主要用三个命令：

* eval
* evalsha
* script load

```shell
# 语法：EVAL script numkeys key [key ...] arg [arg ...]
# key：代表要操作的rediskey
# arg：可以传自定义的参数
# numkeys：用来确定key有几个
# script：就是你写的lua脚本
# lua脚本里面使用KEYS[1]和ARGV[1]来获取传递的key和arg
redis> eval "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 key1 key2 first second
1) "key1"
2) "key2"
3) "first"
4) "second"
```

在用eval命令的时候，可以注意到每次都要把执行的脚本发送过去，这样势必会有一定的网络开销，所以redis对lua脚本做了缓存，通过script load 和 evalsha实现
script load命令会在redis服务器缓存你的lua脚本，并且返回脚本内容的SHA1校验和，然后通过evalsha 传递SHA1校验和来找到服务器缓存的脚本进行调用，这两个命令的格式以及使用方式如下：

```shell
# 语法：SCRIPT LOAD script
# 语法：EVALSHA sha1 numkeys key [key ...] arg [arg ...]
redis> SCRIPT LOAD "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}"
"232fd51614574cf0867b83d384a5e898cfd24e5a"

redis> EVALSHA 232fd51614574cf0867b83d384a5e898cfd24e5a  2 key1 key2 first second
1) "key1"
2) "key2"
3) "first"
4) "second"
```

#### lua Debug

在运行lua的eval,加上-ldb即可开启debug功能,debug只支持eval命令，如下：

`./redis-cli --ldb --eval /tmp/script.lua mykey somekey , arg1 arg2`

redis lua script debug命令与jdk jdb有些类似，但命令更加丰富。详细命令可以通过`lua debugger> help`了解。

## Redis 的常用命令 （需要进一步整理）

例如原子增减、对不同数据结构进行操作的命令等

```shell
# 键自增返回自增后的值，可用于计数器场景
incr key
# Setnx（SET if Not eXists） 命令在指定的 key 不存在时
# 设置成功，返回 1 。 设置失败，返回 0；为 key 设置指定的值，可用于互斥锁
setnx key_name value
```

## 持久化

Redis中数据存储模式有2种：cache-only,persistence;

> * cache-only即只做为“缓存”服务，不持久数据，数据在服务终止后将消失，此模式下也将不存在“数据恢复”的手段，是一种安全性低/效率高/容易扩展的方式；
> * persistence即为内存中的数据持久备份到磁盘文件，在服务重启后可以恢复，此模式下数据相对安全。

对于persistence持久化存储，Redis 提供了 RDB(Redis DataBase) 和 AOF(Append-only file) 两种持久化方式，RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是以文本日志的形式记录 Redis 处理的每一个写入或删除操作。

### RDB

RDB是在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。

* 优点：使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能
* 缺点：RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

RDB 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。另一点需要注意的是，每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步增数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，可能会严重影响性能。

### AOF

Append-only file，将“操作 + 数据”以格式化指令的方式追加到操作日志文件的尾部，在append操作返回后(已经写入到文件或者即将写入)，才进行实际的数据变更，“日志文件”保存了历史所有的操作过程；当server需要数据恢复时，可以直接replay此日志文件，即可还原所有的操作过程。AOF相对可靠，它和mysql中bin.log、apache.log、zookeeper中txn-log简直异曲同工。AOF文件内容是字符串，非常容易阅读和解析。

* 优点：可以保持更高的数据完整性，如果设置追加file的时间是1s，如果redis发生故障，最多会丢失1s的数据；且如果日志写入不完整支持redis-check-aof来进行日志修复；AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）。
* 缺点：AOF文件比RDB文件大，且恢复速度慢。

我们可以简单的认为AOF就是日志文件，此文件只会记录“变更操作”(例如：set/del等)，如果server中持续的大量变更操作，将会导致AOF文件非常的庞大，意味着server失效后，数据恢复的过程将会很长；**事实上，一条数据经过多次变更，将会产生多条AOF记录，其实只要保存当前的状态，历史的操作记录是可以抛弃的；因为AOF持久化模式还伴生了“AOF rewrite”。**

### 哪种更好？当前都好都用

假设集群：Master<--Slave1<--Slave2，Master不设置备份策略更利于性能，Slave1设置AOF，Slave2设置RDB，完整性Slave1更好，如果要快速恢复使用Slave2

## 高可用

集群方案比较

### 哨兵模式

在Redis2.8之后提供了哨兵模式，借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做主从切换，将某一台slave作为master，在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，性能和高可用性等各方面表现一般；且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。

### 高可用集群模式

Redis3.0开始支持集群，redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。redis集群的性能和高可用性均优于之前版本的哨兵模式。

#### Redis集群原理（需要进一步理解整理）

#### Redis主从模式

##### Redis主从模式的必要性

* 备份数据：当一个节点损坏时，数据因为有备份，可以方便恢复。
* 负载均衡：避免所有客户端都访问一个节点，有了主从模式后，查询操作就可以通过查询从节点来完成。

##### Redis主从模式的特点

* 一个Master可以有多个Slaves
* 默认配置下，**master节点**可以进行**读、写**，**slave节点**只能进行**读操作**，写操作被禁止
* master节点挂了以后，不影响slave节点的读；slave节点挂了，不影响其他master节点的读和写，重新启动后会将数据从master节点同步过来。

master节点都挂了以后，redis就不会对外提供写服务了，所以生产环境一般都是多主从集群部署。

#### Cluster数据分布

##### 一致性hash

原理：数据做成token环，为每一个节点分配一个token，key做了hash后会落在两个node2之间，顺时针找离它最近的节点。是在客户端分片。节点比较多的时候建议使用这种方式。节点伸缩的时候只影响临近的节点，还是要使用多倍扩容，不然会数据倾斜。

#### 虚拟槽分区 [?]

## Redis客户端与服务端交互过程

## 缓存常见问题

### 缓存更新方式

* 数据源发生变化时主动更新缓存；
* 无法感知数据源或不能及时监听数据源变化时，设置数据不一致的最大容忍时间；
* 另外在配合后台扫描更新，定时对数据进行分批更新。

### 数据不一致

缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 Redis 因为网络原因请求超时；或者是异步更新失败导致。

解决的办法是：如果服务对耗时不是特别敏感可以增加重试；如果服务对耗时敏感可以通过异步补偿任务来处理失败的更新，或者短期的数据不一致不会影响业务，只要下次更新时可以成功，能保证最终一致性就可以。

### 缓存穿透

产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户id频繁请求接口，导致查询缓存不命中，然后穿透 DB 查询依然不命中。这时会有大量请求穿透缓存访问到 DB。

解决办法：

* 对不存在的用户，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。这个方法并不能很好解决问题；a).可能导致缓存中存储大量无用数据 b).后期业务产生ID与有被缓存空的冲突；
* 使用 BloomFilter 过滤器

布隆过滤器原理：利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在return，存在就去查DB刷新KV再return [?]

### 缓存击穿

缓存击穿，就是某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。

解决办法：

* 可以使用互斥锁更新，查询数据库前获取互斥锁，更新缓存后释放锁；
* 使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。那么sleep时间最短的可能会去访问数据源并更新缓存
* 后台定时主动更新缓存，定时频率可稍高于缓存失效时间，或者设置热点数据永远不过期，有更新操作就更新缓存就好了
* 针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效

### 缓存雪崩

产生的原因：Redis挂掉，这时所有的请求都会穿透到 DB；大量热点key同时失效。

解决方法：

* 使用快速失败的熔断策略，减少 DB 瞬间压力
* 使用高可用集群模式来尽量保证缓存服务的高可用
* 针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效，或者设置热点数据永远不过期，有更新操作就更新缓存就好了

### 其他注意事项

* Redis 是单线程处理请求，应尽量避免耗时较高的单个请求任务，防止相互影响
* Redis 是典型的CPU密集型服务，应避免和其他 CPU 密集型的进程部署在同一机器
* 禁用 Swap 内存交换`sudo swapoff -a`，防止 Redis 的缓存数据交换到硬盘上，影响性能

### Redis 4.0、5.0 中的新特性

例如支持多播的可持久化消息队列 Stream；通过 Module 系统来进行定制功能扩展等等

## 其他问题

> Redis 在内存中的存储结构?  [?]

这对评估使用容量会很有帮助

> Redis 的数据失效方式和剔除策略  [?]

Redis的过期策略，是有定期删除+惰性删除两种。

* 定期：默认100ms就随机抽一些设置了过期时间的key，去检查是否过期
* 惰性：查询时检查过期没，过期就删了并且不返回

> Redis为啥那么快？  [?]

Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）

* 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
* 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；[?]
* 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
* 使用多路I/O复用模型，非阻塞IO；[?]
* 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；[?]

> 单机会有瓶颈，怎么解决这个瓶颈？  [?]

通过集群部署解决都写并发，部署多个Master，每个Master部署挂载多个Slave Node，Master支持读写,Slave支持读

> 主从之间的数据怎么同步的？  [?]

启动一台slave 的时候，他会发送一个psync命令给master ，如果是这个slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成RDB快照，还会把新的写请求都缓存在内存中，RDB文件生成后，master会将这个RDB发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命令都发给slave。

## 更多典型使用案例/场景

### 红包秒杀

#### 实现思路

可使用lua优化合并红包派发与红包数量扣减部分逻辑，不是因为lua的原子性，lua能减少网络开销

#### 部分核心代码

## 优化

* Redis是单线程，服务器是多核，生产环境部署多个实例，避免资源浪费
* Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化
* 如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次
* 尽量避免在压力较大的主库上增加从库
* 为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master<--Slave1<--Slave2<--Slave3.......，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变
